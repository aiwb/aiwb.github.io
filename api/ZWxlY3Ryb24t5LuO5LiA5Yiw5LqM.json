{"title":"electron 从一到二","date":"2019-11-01T07:49:01.000Z","link":"electron-从一到二","comments":true,"tags":["electron","im","node-gyp","protocol-buffer"],"updated":"2020-04-15T21:36:20.855Z","content":"<h2 id=\"〇、介绍\">〇、介绍<a href=\"electron-从一到二#〇、介绍\"></a></h2><p>上一节介绍了 electron 的基础使用，介绍的比较简单，照着文章一步步基本可以打出一个简单的原型项目啦。</p>\n<p>这篇文章介绍一下 electron IM 应用开发中要考虑的一些问题。</p>\n<p>本文主要包括：</p>\n<ol>\n<li>消息加密解密</li>\n<li>消息序列化</li>\n<li>网络传输协议</li>\n<li>私有数据通信协议</li>\n<li>多进程优化</li>\n<li>消息本地存储</li>\n<li>新消息 tray 图标闪烁</li>\n<li>项目自动更新</li>\n<li>进程间通信</li>\n<li>其他</li>\n</ol>\n<a id=\"more\"></a>\n\n<h2 id=\"一、消息加密解密\">一、消息加密解密<a href=\"electron-从一到二#一、消息加密解密\"></a></h2><h3 id=\"背景\">背景<a href=\"electron-从一到二#背景\"></a></h3><p>对聊天软件而言，消息的保密性就比较重要了，谁也不希望自己的聊天内容泄露甚至暴露在众人的前面。所以在收发信息的时候，我们需要对信息做一些加密解密操作，保证信息在网络中传输的时候是加密的状态。</p>\n<h3 id=\"简单的实现方法\">简单的实现方法<a href=\"electron-从一到二#简单的实现方法\"></a></h3><p>可能大家马上就想这还不简单，项目里写个加密解密的方法。收到消息时候先解密，发送消息时候先加密，服务端收到加密消息直接存储起来。</p>\n<p>这样写理论上也没有问题，不过客户端直接写加解密方法有一些不好的地方。</p>\n<ol>\n<li>容易被逆向。前端代码比较容易被逆向。</li>\n<li>性能较差。在公司中可能加了很多项目的群组，各个群组中都会收到很多消息，前端处理起来比较慢。</li>\n<li>类似的如果都在客户端实现加解密算法，那么 ios, android 等不同客户端，因为使用的开发语言不同，都要要分别实现相同的算法，增加维护成本。</li>\n</ol>\n<h3 id=\"我们的方案\">我们的方案<a href=\"electron-从一到二#我们的方案\"></a></h3><p>我们使用<a href=\"https://nodejs.org/api/addons.html\" target=\"_blank\" rel=\"noopener\">C++ Addons</a> 提供的能力，在 c++ sdk 中实现加解密算法，让 js 可以像调用 Node 模块一样去调用 c++ sdk 模块。这样就一次性解决了上面提到的所有问题。</p>\n<p><img src=\"https://i.loli.net/2019/11/21/EAY3CdHyuOcQJ1p.png\" alt class=\"article-img\"></p>\n<p>开发完 addon, 使用 <a href=\"https://github.com/nodejs/node-gyp\" target=\"_blank\" rel=\"noopener\">node-gyp</a> 来构建 C++ Addons. node-gyp 会根据 binding.gyp 配置文件调用各平台上的编译工具集来进行编译。如果要实现跨平台，需要按不同平台编译 nodejs addon，在 <code>binding.gyp</code> 中按平台配置加解密的静态链接库。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"targets\"</span>: [&#123;</span><br><span class=\"line\">        <span class=\"attr\">\"conditions\"</span>: [</span><br><span class=\"line\">            [<span class=\"string\">\"OS=='mac'\"</span>, &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"libraries\"</span>: [</span><br><span class=\"line\">                    <span class=\"string\">\"&lt;(module_root_dir)/lib/mac/security.a\"</span></span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;],</span><br><span class=\"line\">            [<span class=\"string\">\"OS=='win'\"</span>, &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"libraries\"</span>: [</span><br><span class=\"line\">                    <span class=\"string\">\"&lt;(module_root_dir)/lib/win/security.lib\"</span></span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;],</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        ]</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;]</span><br></pre></td></tr></table></div></figure>\n\n<p>当然也可以根据需要添加更多平台的支持，如 linux、unix。</p>\n<p>对 c++ 代码进程封装 addon 的时候，可以使用 <a href=\"https://github.com/nodejs/node-addon-api\" target=\"_blank\" rel=\"noopener\">node-addon-api</a>. node-addon-api 包对 <a href=\"https://nodejs.org/api/n-api.html\" target=\"_blank\" rel=\"noopener\">N-API</a> 做了封装，并抹平了 nodejs 版本间的兼容问题。封装大大降低了非职业 c++ 开发编写 node addon 的成本。关于 node-addon-api、N-API、NAN 等概念可以参考<a href=\"https://xcoder.in/curriculumvitae/\" target=\"_blank\" rel=\"noopener\">死月</a>同学的文章<a href=\"https://xcoder.in/2017/07/01/nodejs-addon-history/\" target=\"_blank\" rel=\"noopener\">从暴力到 NAN 再到 NAPI——Node.js 原生模块开发方式变迁</a></p>\n<p>打包出 .node 文件后，可以在 electron 应用运行时，调用 <code>process.platform</code> 判断运行的平台，分别加载对应平台的 addon。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (process.platform === <span class=\"string\">'win32'</span>) &#123;</span><br><span class=\"line\">trueaddon = <span class=\"built_in\">require</span>(<span class=\"string\">'../lib/security_win.node'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">trueaddon = <span class=\"built_in\">require</span>(<span class=\"string\">'../lib/security_mac.node'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"二、消息序列化和反序列化\">二、消息序列化和反序列化<a href=\"electron-从一到二#二、消息序列化和反序列化\"></a></h2><h3 id=\"背景-1\">背景<a href=\"electron-从一到二#背景-1\"></a></h3><p>聊天消息直接通过 JSON 解码和传输效率都比较低。</p>\n<h3 id=\"我们的方案-1\">我们的方案<a href=\"electron-从一到二#我们的方案-1\"></a></h3><p>这里我们引入谷歌的 <a href=\"https://developers.google.com/protocol-buffers\" target=\"_blank\" rel=\"noopener\">Protocol Buffer</a> 提升效率。关于 Protocol Buffer 更多的介绍，可以查看底部的参考文章。</p>\n<p>node 环境中使用 Protocol Buffer 可以用 <a href=\"https://www.npmjs.com/package/protobufjs\" target=\"_blank\" rel=\"noopener\">protobufjs</a> 包。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i protobuff -S</span><br></pre></td></tr></table></div></figure>\n\n<p>然后通过 <a href=\"https://www.npmjs.com/package/protobufjs#pbjs-for-javascript\" target=\"_blank\" rel=\"noopener\">pbjs</a> 命令将 proto 文件转换成 pbJson.js</p>\n<p><code>pbjs -t json-module --sparse --force-long -w commonjs -o src/im/data/pbJson.js proto/*.proto</code></p>\n<p>要在 js 中支持后端 int64 格式数据，需要使用 <a href=\"https://www.npmjs.com/package/long\" target=\"_blank\" rel=\"noopener\">long</a> 包配置下 protobuf。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Long = <span class=\"built_in\">require</span>(<span class=\"string\">\"long\"</span>);</span><br><span class=\"line\">$protobuf.util.Long = Long;</span><br><span class=\"line\">$protobuf.configure();</span><br><span class=\"line\">$protobuf.util.LongBits.prototype.toLong = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toLong</span> (<span class=\"params\">unsigned</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> $protobuf.util.Long(<span class=\"keyword\">this</span>.lo | <span class=\"number\">0</span>, <span class=\"keyword\">this</span>.hi | <span class=\"number\">0</span>, <span class=\"built_in\">Boolean</span>(unsigned)).toString();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n\n<p>后面就是消息的压缩转换了，将 js 字符串转成 bp 格式。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PbJson <span class=\"keyword\">from</span> <span class=\"string\">'./path/to/src/im/data/pbJson.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 封装数据</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> encodedMsg = PbJson.lookupType(<span class=\"string\">'pb-api'</span>).ctor.encode(data).finish();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解封数据</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> decodedMsg = PbJson.lookupType(<span class=\"string\">'pb-api'</span>).ctor.decode(buff);</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"三、网络传输协议\">三、<a href=\"https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">网络传输协议</a><a href=\"electron-从一到二#三、网络传输协议\"></a></h3><p>传输层协议有 UDP/TCP 等。UDP 实时性好，但是可靠性不好。这里选用 TCP 协议。应用层分别使用 WS 协议保持长连接保证实时传输消息，HTTPS 协议传输消息外的其他状态数据。这里给个例子实现一个简单的 WS 管理类</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; EventEmitter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'events'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> webSocketConfig = <span class=\"string\">'wss://xxxx'</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocketServer</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventEmitter</span> </span>&#123;</span><br><span class=\"line\">    connect () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.socket)&#123;</span><br><span class=\"line\">truetruetrue<span class=\"keyword\">this</span>.removeEvent(<span class=\"keyword\">this</span>.socket);</span><br><span class=\"line\">truetruetrue<span class=\"keyword\">this</span>.socket.close();</span><br><span class=\"line\">truetrue&#125;</span><br><span class=\"line\">truetrue<span class=\"keyword\">this</span>.socket = <span class=\"keyword\">new</span> WebSocket(webSocketConfig);</span><br><span class=\"line\">truetrue<span class=\"keyword\">this</span>.bindEvents(<span class=\"keyword\">this</span>.socket);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    close () &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> getSocket () &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bindEvents() &#123;&#125;</span><br><span class=\"line\">    removeEvent() &#123;&#125;</span><br><span class=\"line\">    onMessage (e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息解包</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> decodedMSg = <span class=\"string\">'xxx;</span></span><br><span class=\"line\"><span class=\"string\">        this.emit(decodedMSg);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    async send(sendData) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        const socket = await this.getSocket()</span></span><br><span class=\"line\"><span class=\"string\">        socket.send(sendData);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    ...</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>https 协议的就不介绍了，大家天天用。</p>\n<h2 id=\"四、私有数据通信协议\">四、私有<a href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">数据通信协议</a><a href=\"electron-从一到二#四、私有数据通信协议\"></a></h2><p>上几步实现了把聊天消息序列化和反序列化，也实现了通过 websocket 发送和接收消息，但还不能直接这样发送聊天消息。我们还需要一个数据通信协议。给消息增加一些属性，如 id 用来关联收发的消息，type 标记消息类型，version 标记调用接口的版本，api 标记调用的接口等。然后定义一个编码格式， 用 ArrayBuffer 将消息包装起来，放到 ws 中发送，以二进制流的方式传输。</p>\n<p>协议设计需要保证足够的扩展性，不然修改的时候需要同时修改前后端，比较麻烦。</p>\n<p>下面是个简化的例子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PocketManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventEmitter</span> </span>&#123;</span><br><span class=\"line\">    encode (id, type, version, api, payload) &#123;</span><br><span class=\"line\">truetrue<span class=\"keyword\">let</span> headerBuffer = Buffer.alloc(<span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> payloadBuffer = Buffer.alloc(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> keyLength = Buffer.from(id).length;</span><br><span class=\"line\">        headerBuffer.writeUInt16BE(keyLength, offset);</span><br><span class=\"line\">        offset += <span class=\"number\">2</span>;</span><br><span class=\"line\">        headerBuffer.write(id, offset, offset + keyLength, <span class=\"string\">'utf8'</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        payloadBuffer = Buffer.from(payload);</span><br><span class=\"line\">truetrue<span class=\"keyword\">return</span> Buffer.concat([headerBuffer, payloadBuffer], <span class=\"number\">8</span> + payloadBuffer.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    decode () &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"五、多进程优化\">五、多进程优化<a href=\"electron-从一到二#五、多进程优化\"></a></h2><p>IM 界面有很多模块，聊天模块，群管理模块，历史消息模块等。另外消息通信逻辑不应该和界面逻辑放一个进程里，避免界面卡顿时候影响消息的收发。这里有个简单的实现方法，把不同的模块放到 electorn 不同的窗口中，因为不同的窗口由不同的进程管理，我们就不需要自己管理进程了。下面实现一个窗口管理类。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; EventEmitter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'events'</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventEmitter</span> </span>&#123;</span><br><span class=\"line\">    open () &#123;&#125;</span><br><span class=\"line\">    close () &#123;&#125;</span><br><span class=\"line\">    isExist () &#123;&#125;</span><br><span class=\"line\">    destroy() &#123;&#125;</span><br><span class=\"line\">    createWindow() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.win = <span class=\"keyword\">new</span> BrowserWindow(&#123;</span><br><span class=\"line\">truetruetrue...this.browserConfig,</span><br><span class=\"line\">truetrue&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>其中 browserConfig 可以在子类中设置，不同窗口可以继承这个基类设置自己窗口属性。通信模块用作后台收发数据，不需要显示窗口，可以设置窗口 width = 0，height = 0 。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseWindow</span> </span>&#123;</span><br><span class=\"line\">    browserConfig = &#123;</span><br><span class=\"line\">truetruewidth: <span class=\"number\">0</span>,</span><br><span class=\"line\">truetrueheight: <span class=\"number\">0</span>,</span><br><span class=\"line\">truetrueshow: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"六、消息存储\">六、消息存储<a href=\"electron-从一到二#六、消息存储\"></a></h2><h3 id=\"背景-2\">背景<a href=\"electron-从一到二#背景-2\"></a></h3><p>IM 软件中可能会有几千个联系人信息，无数的聊天记录。如果每次都通过网络请求访问，比较浪费带宽，影响性能。</p>\n<h3 id=\"讨论\">讨论<a href=\"electron-从一到二#讨论\"></a></h3><p>electorn 中可以使用 localstorage, 但是 localstorage 有大小限制，实际大多只能存 5M 信息，超过存入大小会报错。</p>\n<p>有些同学可能还会想到 <a href=\"https://www.w3.org/TR/webdatabase/\" target=\"_blank\" rel=\"noopener\">websql</a>, 但这个技术标准已经被废弃了。</p>\n<p>浏览器内置的 <a href=\"https://www.w3.org/TR/IndexedDB-2/\" target=\"_blank\" rel=\"noopener\">indexedDB</a> 也是一个可选项。不过这个也有限制，也没有 sqlite 一样丰富的生态工具可以用。</p>\n<h3 id=\"方案\">方案<a href=\"electron-从一到二#方案\"></a></h3><p>这里我们选用 sqlite。在 node 中使用 sqlite 可以直接用 <a href=\"https://www.npmjs.com/package/sqlite3\" target=\"_blank\" rel=\"noopener\">sqlite3</a> 包。</p>\n<p>可以先写个 DAO 类</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sqlite3 <span class=\"keyword\">from</span> <span class=\"string\">'sqlite3'</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DAO</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(dbFilePath) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.db = <span class=\"keyword\">new</span> sqlite3.Database(dbFilePath, (err) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    run(sql, params = []) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.db.run(sql, params, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">                    reject(err);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    resolve(&#123; <span class=\"attr\">id</span>: <span class=\"keyword\">this</span>.lastID &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>再写个 base Model</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(dao, tableName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dao = dao;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tableName = tableName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>(id) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.dao.run(<span class=\"string\">`DELETE FROM <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.tableName&#125;</span> WHERE id = ?`</span>, [id]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>其他 Model 比如消息、联系人等 Model 可以直接继承这个类，复用 delete/getById/getAll 之类的通用方法。如果不喜欢手动编写 SQLite 语句，可以引入 <a href=\"https://www.npmjs.com/package/knex\" target=\"_blank\" rel=\"noopener\">knex</a> 语法封装器。当然也可以直接时髦点用上 <a href=\"https://en.wikipedia.org/wiki/Object-relational_mapping\" target=\"_blank\" rel=\"noopener\">orm</a> ，比如 <a href=\"https://typeorm.io\" target=\"_blank\" rel=\"noopener\">typeorm</a> 什么的。</p>\n<p>使用的时候</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dao = <span class=\"keyword\">new</span> AppDAO(<span class=\"string\">'path/to/database-file.sqlite3'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> messageModel = <span class=\"keyword\">new</span> MessageModel(dao);</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"七、新消息-tray-图标闪烁\">七、新消息 tray 图标闪烁<a href=\"electron-从一到二#七、新消息-tray-图标闪烁\"></a></h2><p>electron 没有提供专用的 <a href=\"https://electronjs.org/docs/api/tray\" target=\"_blank\" rel=\"noopener\">tray</a> 闪烁的接口，我们可以简单的使用切换 tray 图标来实现这个功能。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Tray, nativeImage &#125; <span class=\"keyword\">from</span> <span class=\"string\">'electron'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrayManager</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    setState() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置默认状态</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">truestartBlink()&#123;</span><br><span class=\"line\">truetrue<span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.tray)&#123;</span><br><span class=\"line\">truetruetrue<span class=\"keyword\">return</span>;</span><br><span class=\"line\">truetrue&#125;</span><br><span class=\"line\">truetrue<span class=\"keyword\">let</span> emptyImg = nativeImage.createFromPath(path.join(__dirname, <span class=\"string\">'./empty.ico'</span>));</span><br><span class=\"line\">truetrue<span class=\"keyword\">let</span> noticeImg = nativeImage.createFromPath(path.join(__dirname, <span class=\"string\">'./newMsg.png'</span>));</span><br><span class=\"line\">truetrue<span class=\"keyword\">let</span> visible;</span><br><span class=\"line\">truetrueclearInterval(<span class=\"keyword\">this</span>.trayTimer);</span><br><span class=\"line\">truetrue<span class=\"keyword\">this</span>.trayTimer = setInterval(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">truetruetruevisible = !visible;</span><br><span class=\"line\">truetruetrue<span class=\"keyword\">if</span>(visible)&#123;</span><br><span class=\"line\">truetruetruetrue<span class=\"keyword\">this</span>.tray.setImage(noticeImg);</span><br><span class=\"line\">truetruetrue&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">truetruetruetrue<span class=\"keyword\">this</span>.tray.setImage(emptyImg);</span><br><span class=\"line\">truetruetrue&#125;</span><br><span class=\"line\">truetrue&#125;,<span class=\"number\">500</span>);</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">true<span class=\"comment\">//停止闪烁</span></span><br><span class=\"line\">truestopBlink()&#123;</span><br><span class=\"line\">truetrueclearInterval(<span class=\"keyword\">this</span>.trayTimer);</span><br><span class=\"line\">truetrue<span class=\"keyword\">this</span>.setState();</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"八、项目自动更新\">八、项目自动更新<a href=\"electron-从一到二#八、项目自动更新\"></a></h2><p>一般有几种不同的更新策略，可以一种或几种结合使用，提升体验。</p>\n<p>第一种是整个软件更新。这种方式比较暴力，体验不好，打开应用检查到版本变更，直接重新下载整个应用替换老版本。改一行代码，让用户冲下百来兆的文件</p>\n<p>第二种是检测文件变更，下载替换老文件进行升级。</p>\n<p>第三种是直接将 view 层文件放在线上，electron 壳加载线上页面访问。有变更发布线上页面就可以。</p>\n<h2 id=\"九、进程间通信\">九、进程间通信<a href=\"electron-从一到二#九、进程间通信\"></a></h2><p>上一篇文章中，有同学问怎么处理进程间通信。electron 进程间通信主要用到 <a href=\"https://electronjs.org/docs/api/ipc-main\" target=\"_blank\" rel=\"noopener\">ipcMain</a> 和 <a href=\"https://electronjs.org/docs/api/ipc-renderer\" target=\"_blank\" rel=\"noopener\">ipcRenderer</a>.</p>\n<p><img src=\"https://i.loli.net/2019/11/20/uYMld67RHh4WGgj.png\" alt class=\"article-img\"></p>\n<p>可以先写个发消息的方法。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; remote, ipcRenderer, ipcMain &#125; <span class=\"keyword\">from</span> <span class=\"string\">'electron'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sendIPCEvent</span>(<span class=\"params\">event, ...data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">require</span>(<span class=\"string\">'./is-electron-renderer'</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> currentWindow = remote.getCurrentWindow();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentWindow) &#123;</span><br><span class=\"line\">            currentWindow.webContents.send(event, ...data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ipcRenderer.send(event, ...data);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ipcMain.emit(event, <span class=\"literal\">null</span>, ...data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> sendIPCEvent;</span><br></pre></td></tr></table></div></figure>\n\n<p>这样不管在主进程还是渲染进程，直接调用这个方法就可以发消息。对于某些特定功能的消息，还可以做一些封装，比如所有推送消息可以封装一个方法，通过方法中的参数判断具体推送的消息类型。main 进程中根据消息类型，处理相关逻辑，或者对消息进行转发。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ipcMainManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventEmitter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        ipcMain.on(<span class=\"string\">'imPush'</span>, (name, data) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.emit(name, data);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.listern();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    listern() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.on(<span class=\"string\">'imPush'</span>, (name, data) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ipcRendererManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventEmitter</span> </span>&#123;</span><br><span class=\"line\">    push (name, data) &#123;</span><br><span class=\"line\">        ipcRenderer.send(<span class=\"string\">'imPush'</span>, name, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"十、其他\">十、其他<a href=\"electron-从一到二#十、其他\"></a></h2><p>还有同学提到日志处理功能。这个和 electron 关系不大，是 node 项目通用的功能。可以选用 <a href=\"https://www.npmjs.com/package/winston\" target=\"_blank\" rel=\"noopener\">winston</a> 之类第三方包。本地日志的话注意一下存储的路径，定期清理等功能点，远程日志提交到接口就可以了。获取路径可以写些通用的方法，如：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> electron <span class=\"keyword\">from</span> <span class=\"string\">'electron'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserDataPath</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">require</span>(<span class=\"string\">'./is-electron-renderer'</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> electron.remote.app.getPath(<span class=\"string\">'userData'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> electron.app.getPath(<span class=\"string\">'userData'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> getUserDataPath;</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"PS\">PS<a href=\"electron-从一到二#PS\"></a></h2><p>有问题可以加我微信交流：</p>\n<img src=\"https://i.loli.net/2019/11/21/FDfyaV92ONl4bc6.jpg\" width=\"200\" height=\"200\" class=\"article-img\">\n\n<p>还可以关注我的博客<a href=\"https://wuwb.me/\" target=\"_blank\" rel=\"noopener\">前端印象 https://wuwb.me/</a>，跟踪最新分享。</p>\n<h2 id=\"参考\">参考<a href=\"electron-从一到二#参考\"></a></h2><ul>\n<li><a href=\"https://iweiyun.github.io/2019/01/04/node-cpp-addon/\" target=\"_blank\" rel=\"noopener\">node-cpp-addon</a></li>\n<li><a href=\"https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html\" target=\"_blank\" rel=\"noopener\">serialization-vs-deserialization</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/53339153\" target=\"_blank\" rel=\"noopener\">Protobuf比JSON性能更好</a></li>\n<li><a href=\"https://fed.taobao.org/blog/2016/09/21/type-casts-between-node-and-cpp/\" target=\"_blank\" rel=\"noopener\">Node.js 和 C++ 之间的类型转换</a></li>\n<li><a href=\"https://www.npmtrends.com\" target=\"_blank\" rel=\"noopener\">npmtrends</a></li>\n</ul>\n","prev":{"title":"History","link":"docs-javascript-MDN-web-api-2019-11-04-History"},"next":{"title":"Performance","link":"docs-javascript-MDN-web-api-2019-11-01-performance"},"plink":"https://wuwb.github.io/electron-从一到二/","toc":[{"title":"〇、介绍","id":"〇、介绍","index":"1"},{"title":"一、消息加密解密","id":"一、消息加密解密","index":"2","children":[{"title":"背景","id":"背景","index":"2.1"},{"title":"简单的实现方法","id":"简单的实现方法","index":"2.2"},{"title":"我们的方案","id":"我们的方案","index":"2.3"}]},{"title":"二、消息序列化和反序列化","id":"二、消息序列化和反序列化","index":"3","children":[{"title":"背景","id":"背景-1","index":"3.1"},{"title":"我们的方案","id":"我们的方案-1","index":"3.2"},{"title":"三、<a>网络传输协议</a>","id":"三、网络传输协议","index":"3.3"}]},{"title":"四、私有<a>数据通信协议</a>","id":"四、私有数据通信协议","index":"4"},{"title":"五、多进程优化","id":"五、多进程优化","index":"5"},{"title":"六、消息存储","id":"六、消息存储","index":"6","children":[{"title":"背景","id":"背景-2","index":"6.1"},{"title":"讨论","id":"讨论","index":"6.2"},{"title":"方案","id":"方案","index":"6.3"}]},{"title":"七、新消息 tray 图标闪烁","id":"七、新消息-tray-图标闪烁","index":"7"},{"title":"八、项目自动更新","id":"八、项目自动更新","index":"8"},{"title":"九、进程间通信","id":"九、进程间通信","index":"9"},{"title":"十、其他","id":"十、其他","index":"10"},{"title":"PS","id":"PS","index":"11"},{"title":"参考","id":"参考","index":"12"}],"reward":true,"copyright":{"author":"吴文斌","link":"<a href=\"https://wuwb.github.io/electron-从一到二/\" title=\"electron 从一到二\">https://wuwb.github.io/electron-从一到二/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\\\"https://creativecommons.org/licenses/by-nc-nd/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)"}}